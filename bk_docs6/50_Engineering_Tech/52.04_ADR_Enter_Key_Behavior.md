---
title: "ADR 004: Enterキーの動作（段落 vs 改行）"
type: technical
status: proposed
role: TechLead
tags: [adr, editor, ux, tiptap]
---

# ADR: Enterキーの動作（段落 vs 改行）

## ステータス

提案中 (Proposed)

## コンテキスト

### 現在の動作

Tiptap（StarterKit）のデフォルト動作：
- **Enter**: 新しい段落（`<p>`タグ）を作成
- **Shift+Enter**: 行内改行（`<br>`タグ）を挿入

### 問題点

小説執筆においては、改行（`<br>`）の使用頻度が段落区切り（`<p>`）よりも高い。

#### 例：会話文

```
「こんにちは」
　彼女は言った。
「元気ですか？」
```

この場合、現在の実装（Enterで新しい`<p>`）では：

```html
<p>「こんにちは」</p>
<p>　彼女は言った。</p>
<p>「元気ですか？」</p>
```

しかし、意味的には以下のいずれかが適切：

**パターンA: 1つの段落**
```html
<p>「こんにちは」<br>　彼女は言った。<br>「元気ですか？」</p>
```

**パターンB: 2つの段落**
```html
<p>「こんにちは」<br>　彼女は言った。</p>
<p>「元気ですか？」</p>
```

### 一般的なエディタとの比較

| エディタ | Enter動作 | Shift+Enter動作 |
|---------|----------|----------------|
| Microsoft Word | 新しい段落 | 改行 |
| Google Docs | 新しい段落 | 改行 |
| 青空エディタ | 改行 | - |
| 小説家になろうエディタ | 改行（改行コード） | - |
| Notion | 新しいブロック | 改行 |

**小説執筆特化エディタは改行優先の傾向**

## 検討した選択肢

### 選択肢1: スマート改行（推奨）

**概要**:
- **Enter（通常）**: `<br>`タグを挿入（改行）
- **Enter（空行で）**: 新しい`<p>`タグを作成（段落区切り）
- Shift+Enterは不要

**動作例**:
```
「こんにちは」[Enter] → <br>を挿入
　彼女は言った。[Enter] → <br>を挿入
[Enter] ← 空行でEnter → 新しい<p>を作成
「元気ですか？」
```

**メリット**:
- 最も直感的（視覚的に「空行＝段落区切り」は自然）
- Enterキーだけで完結（Shiftの組み合わせ不要）
- Markdownの動作に類似（学習コストが低い）
- 小説の慣習に一致（場面転換は空行で表現）
- 会話文や詩の執筆がスムーズ

**デメリット**:
- 実装がやや複雑（空行判定のロジックが必要）
- エッジケースの考慮が必要（複数の`<br>`など）

### 選択肢2: 現状維持

**概要**:
- **Enter**: 新しい`<p>`タグを作成
- **Shift+Enter**: `<br>`タグを挿入

**メリット**:
- 一般的なエディタの慣習に準拠
- HTML構造としては正しい

**デメリット**:
- 小説執筆では頻繁にShift+Enterを使う必要がある
- UXが悪い（多くのユーザーが不満を持つ可能性）

### 選択肢3: モード切り替え機能

**概要**:
- 設定またはツールバーボタンで切り替え可能
- 「小説モード」「標準モード」

**メリット**:
- 両方のユースケースに対応
- ユーザーが選択できる

**デメリット**:
- 実装が複雑
- 設定項目が増える
- モード切り替えを忘れると混乱

### 選択肢4: 自動検出

**概要**:
- コンテンツの種類を自動判定
- 会話文（「」）が多い → 改行優先
- 通常の文章 → 段落優先

**メリット**:
- ユーザー設定不要
- コンテキストに応じた動作

**デメリット**:
- 実装が非常に複雑
- 予測不可能な動作になる可能性
- パフォーマンスへの影響

## 決定

**選択肢1: スマート改行**を採用します。

### 理由

1. **ターゲットユーザー**: Astranoteは小説家向けに特化
2. **使用頻度**: 小説執筆では改行 >> 段落区切り
3. **直感性**: 空行で段落区切りは視覚的に自然
4. **UX**: Enterキーだけで完結、Shift不要
5. **類似性**: Markdownなど他のツールとの類似性で学習コストが低い
6. **小説の慣習**: 実際の小説でも場面転換は空行で表現される

### 代替案の却下理由

- **選択肢2（現状維持）**: 小説執筆には不向き
- **選択肢3（モード切り替え）**: 複雑さに見合うメリットがない
- **選択肢4（自動検出）**: 予測不可能で実装コストが高い

## 実装計画

### 1. カスタム拡張の作成

```typescript
// HeadingEnterExtension の下に追加
const SmartEnterExtension = Extension.create({
  name: 'smartEnter',

  addKeyboardShortcuts() {
    return {
      'Enter': ({ editor }) => {
        const { state } = editor;
        const { $from } = state.selection;
        const currentNode = $from.parent;

        // 現在の段落が空かチェック
        const isEmpty = currentNode.content.size === 0;

        // または、最後の子要素がhardBreak（<br>）で、その前も空の場合
        const lastChild = currentNode.lastChild;
        const isEmptyLine =
          isEmpty ||
          (lastChild?.type.name === 'hardBreak' && currentNode.content.size === 1);

        if (isEmptyLine) {
          // 空行の場合: 段落を分割
          return editor.commands.splitBlock();
        } else {
          // 通常の場合: 改行を挿入
          return editor.commands.setHardBreak();
        }
      },
    };
  },
});
```

### 2. エディタに拡張を追加

```typescript
editor = new Editor({
  element: editorElement,
  extensions: [
    StarterKit.configure({
      heading: {
        levels: [2],
      },
      // hardBreakをtrueにして有効化
      hardBreak: true,
    }),
    Placeholder.configure({
      placeholder: 'ここから執筆を開始...',
    }),
    Ruby,
    HeadingEnterExtension,
    SmartEnterExtension, // 新規追加
  ],
  // ...
});
```

### 3. CSSでの改行表示調整

```css
/* global.css */

/* 改行（<br>）の後の余白を最小限に */
.ProseMirror br {
  content: '';
  display: block;
  margin-top: 0;
  line-height: inherit;
}

/* 段落間の余白 */
.ProseMirror p {
  margin-bottom: 1em;
}

.ProseMirror p + p {
  margin-top: 0;
}
```

### 4. ユーザーへのガイダンス

初回起動時またはヘルプセクションで説明：

```
執筆のヒント：
- Enter: 改行（会話文や短い行の区切り）
- 空行でEnter: 段落区切り（場面転換や大きな区切り）

例：
「こんにちは」[Enter]
　彼女は言った。[Enter]
[Enter] ← ここで段落が分かれます
```

## エクスポートへの影響

### HTML形式

`<br>`タグはそのまま出力され、ブラウザで正しく表示される。

```html
<p>「こんにちは」<br>　彼女は言った。</p>
<p>「元気ですか？」</p>
```

### プレーンテキスト形式

`<br>`タグは改行文字（`\n`）に変換される。

```typescript
export function htmlToPlainText(html: string): string {
  // ... 既存のコード

  // <br>タグを改行に変換
  const withLineBreaks = withAozoraRuby.replace(/<br\s*\/?>/gi, '\n');

  const parser = new DOMParser();
  const doc = parser.parseFromString(withLineBreaks, 'text/html');

  return doc.body.textContent || '';
}
```

### 青空文庫形式

改行はそのまま改行文字として扱われる。段落区切りは空行で表現。

```
「こんにちは」
　彼女は言った。

「元気ですか？」
```

## 影響範囲

### 変更が必要なファイル

1. **app/src/components/interactive/TiptapEditor.svelte**
   - NovelEnterExtension を追加
   - extensions配列に追加

2. **app/src/styles/global.css**
   - `<br>`タグのスタイル調整

3. **app/src/utils/export.ts**
   - `<br>`タグの適切な処理

### 新規作成が必要なファイル

なし（既存ファイルの修正のみ）

## リスクと緩和策

### リスク1: 既存ユーザーの混乱

**緩和策**:
- リリースノートで明確に説明
- 初回起動時にツールチップ表示
- ヘルプセクションにショートカット一覧を追加

### リスク2: 他のエディタとの互換性

**緩和策**:
- エクスポート時に適切に変換
- インポート時に`<br>`と`<p>`を正しく解釈

### リスク3: アクセシビリティ

**緩和策**:
- `<br>`タグは標準HTMLなのでスクリーンリーダーで正しく読まれる
- セマンティックな構造は維持される

## 今後の検討事項

### Phase 3以降

1. **自動整形機能**: 連続した`<br>`を`<p>`に自動変換するオプション
2. **表示モード**: 編集時と閲覧時で改行の表示を変えるオプション
3. **統計機能**: 段落数と行数を別々にカウント
4. **プリセット**: ジャンルごとの推奨設定（例：詩、台本、小説）

### オープンクエスチョン

- [ ] **Q1**: 連続した`<br>`（空行）の扱いは？
  - 案A: そのまま許可
  - 案B: 2つ以上の連続`<br>`を自動で`<p>`に変換
  - 案C: 連続`<br>`を1つの空白`<p>`に変換

- [ ] **Q2**: 見出しの後の動作は？
  - 案A: 見出しの後は常に新しい段落（現在の実装）
  - 案B: 見出しの後も`<br>`（統一性重視）

- [ ] **Q3**: ツールチップやヘルプの表示タイミングは？
  - 案A: 初回起動時のみ
  - 案B: 最初の10回の使用時
  - 案C: ヘルプメニューにのみ記載

## 変更履歴

| 日付       | 変更者 | 変更内容                               |
| ---------- | ------ | -------------------------------------- |
| 2026/01/28 | Salaim | bkから統合、YAMLフロントマター追加     |

## 関連ドキュメント

- [52.03_ADR_Paragraph_Styling.md](52.03_ADR_Paragraph_Styling.md) - 段落スタイリングADR
- [51.01_TechSpec_Ruby.md](51.01_TechSpec_Ruby.md) - ルビシステム技術仕様
- [53.01_Implementation_Tasks_Multilingual.md](53.01_Implementation_Tasks_Multilingual.md) - 多言語対応実装タスク
